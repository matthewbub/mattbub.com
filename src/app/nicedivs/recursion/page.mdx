# Recursion

## Understanding Recursion

Recursion is when a function calls itself. It's a fundamental programming concept that can seem confusing at first, but once you understand the pattern, it becomes a powerful problem-solving tool.

Every recursive function needs two essential components to work properly. Without both of these, you'll either get incorrect results or crash your program with a stack overflow error.

## The Two Essential Parts

Every recursive function must have a **base case** and a **recursive case**. The base case tells the function when to stop calling itself, while the recursive case handles the logic and calls the function again with modified parameters.

```typescript
function simpleRecursion(n: number): string {
  // Base case: when to stop
  if (n === 0) {
    return "Done!";
  }

  // Recursive case: call ourselves
  return simpleRecursion(n - 1);
}

console.log(simpleRecursion(3)); // "Done!"
```

## Building a Countdown

Let's see recursion in action with a countdown timer. This example shows how the function processes each number and eventually reaches the base case.

```typescript
function countdown(n: number): void {
  // Base case: stop when we reach 0
  if (n === 0) {
    console.log("Blast off! ðŸš€");
    return;
  }

  // Print current number
  console.log(n);

  // Recursive case: countdown with n-1
  countdown(n - 1);
}

countdown(5);
// Output: 5, 4, 3, 2, 1, Blast off! ðŸš€
```

## Returning Values

Recursion becomes more powerful when you return and combine values. This factorial example shows how recursive calls build up a final result as the function calls resolve.

```typescript
function factorial(n: number): number {
  // Base case: factorial of 0 or 1 is 1
  if (n <= 1) {
    return 1;
  }

  // Recursive case: n * factorial of (n-1)
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
// Calculates: 5 * 4 * 3 * 2 * 1 = 120
```

## Working with Arrays

Recursion shines when working with nested structures. Here's how you might sum all numbers in an array, including nested arrays.

```typescript
function sumArray(arr: (number | (number | number[])[])[]) {
  let total = 0;

  for (let item of arr) {
    if (Array.isArray(item)) {
      // Recursive case: sum the nested array
      total += sumArray(item);
    } else {
      // Base case: add the number
      total += item;
    }
  }

  return total;
}

const nested: (number | number[])[] = [1, [2, 3], [4, [5, 6]]];
console.log(sumArray(nested)); // 21
```

## Tree Traversal

One of recursion's most practical applications is traversing tree-like structures. This function finds all files in a directory tree structure.

```typescript
interface FileItem {
  type: "file";
  name: string;
}

interface DirectoryItem {
  type: "directory";
  contents: (FileItem | DirectoryItem)[];
}

type FSItem = FileItem | DirectoryItem;

function findFiles(directory: DirectoryItem): string[] {
  let files: string[] = [];

  for (let item of directory.contents) {
    if (item.type === "file") {
      // Base case: it's a file
      files.push(item.name);
    } else if (item.type === "directory") {
      // Recursive case: explore subdirectory
      files.push(...findFiles(item));
    }
  }

  return files;
}

const fileSystem: DirectoryItem = {
  type: "directory",
  contents: [
    { type: "file", name: "readme.txt" },
    {
      type: "directory",
      contents: [{ type: "file", name: "app.js" }],
    },
  ],
};

console.log(findFiles(fileSystem)); // ["readme.txt", "app.js"]
```

## Avoiding Common Pitfalls

The most common recursion mistake is forgetting the base case or having it unreachable. This creates infinite recursion and crashes your program with a stack overflow error.

```typescript
// BAD: No base case
function badRecursion(n: number): number {
  console.log(n);
  return badRecursion(n - 1); // Never stops!
}

// BAD: Unreachable base case
function alsoBAD(n: number): string {
  if (n === 0) {
    return "done";
  }
  return alsoBAD(n + 1); // n keeps growing!
}

// GOOD: Proper base case
function goodRecursion(n: number): string {
  if (n <= 0) return "done"; // Will always be reached
  return goodRecursion(n - 1);
}

console.log(goodRecursion(3)); // "done"
```

## Wrapping Up

Recursion is just another way to solve problems by breaking them into smaller, similar pieces. It's particularly useful for tree-like structures, mathematical sequences, and divide-and-conquer algorithms.

The key insight is trusting that the recursive call will handle its part correctly. You focus on solving one small piece and let recursion handle the rest. With practice, this pattern becomes second nature for the right types of problems.
